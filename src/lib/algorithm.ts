import { createClient } from '@supabase/supabase-js';

import { EventType, Role, Room } from './supabase';

// Initialize Supabase client with Service Role Key for Admin operations
// We need the service role key to bypass RLS if needed, or ensuring the user is admin
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

if (!process.env.SUPABASE_SERVICE_ROLE_KEY) {
  console.warn('⚠️ SUPABASE_SERVICE_ROLE_KEY ausente. Operações administrativas podem falhar.');
}
// NOTE: For client-side triggering, we should use the user's session.
// For server-side robust logic, we might use a service key if available, but let's stick to the client for now
// and rely on RLS allowing "admin" role to write to 'schedules'.
// Actually, for this "algorithm", it's best to run as a server action with admin privileges.

export const supabase = createClient(supabaseUrl, supabaseServiceKey);

interface Volunteer {
  id: string;
  name: string;
  role: Role;
  room: Room;
  phone: string;
}

interface Event {
  id: string;
  event_date: string; // YYYY-MM-DD
  event_type: EventType;
  day: number; // day of month
}

interface ScheduleEntry {
  event_id: string;
  volunteer_id: string;
  assigned_role: 'professor' | 'auxiliar';
  assigned_room: string | null;
  month: number;
  year: number;
}

interface GenerationResult {
  success: boolean;
  message: string;
  schedule?: ScheduleEntry[];
  logs: string[];
}

export async function generateSchedule(month: number, year: number): Promise<GenerationResult> {
  const logs: string[] = [];
  const log = (msg: string) => logs.push(msg);

  try {
    log(`Iniciando geração de escala para ${month}/${year}`);

    // 1. Fetch Volunteers
    const { data: volunteers, error: volError } = await supabase
      .from('volunteers')
      .select('*')
      .eq('is_active', true);

    if (volError || !volunteers) throw new Error('Erro ao buscar voluntários');
    log(`${volunteers.length} voluntários encontrados.`);

    // 2. Fetch or Generate Events
    let { data: events, error: eventsError } = await supabase
      .from('events')
      .select('*')
      .eq('month', month)
      .eq('year', year)
      .order('event_date');

    if (eventsError) throw new Error('Erro ao buscar eventos');

    if (!events || events.length === 0) {
      log('Nenhum evento encontrado. Gerando dias de culto...');
      // Logic to generate events would go here (already implemented in frontend, reusing availability logic would be better)
      // For now, assuming events exist or are generated by the admin dashboard "Setup" step.
      // If we *must* generate them here:
      await ensureEventsExist(month, year);
      const { data: newEvents } = await supabase.from('events').select('*').eq('month', month).eq('year', year).order('event_date');
      events = newEvents || [];
    }

    if (events.length === 0) throw new Error('Falha ao gerar eventos.');
    log(`${events.length} eventos identificados.`);

    // 3. Fetch Unavailabilities
    const { data: unavailabilities, error: unavailError } = await supabase
      .from('unavailabilities')
      .select('volunteer_id, event_id');

    if (unavailError) throw new Error('Erro ao buscar indisponibilidades');

    // Create a Set for fast lookup: "volunteerId_eventId"
    const unavailableSet = new Set(unavailabilities?.map(u => `${u.volunteer_id}_${u.event_id}`));

    // 4. Fetch History for EBD Rotation
    // ... (to be implemented)

    // Clear existing schedule for this month
    await supabase.from('schedules').delete().eq('month', month).eq('year', year);
    log('Escala anterior limpa.');

    const schedule: ScheduleEntry[] = [];

    // Track usage count for fairness
    const usageCount: Record<string, number> = {};
    volunteers.forEach(v => usageCount[v.id] = 0);

    // Track last date worked for "Rest" constraint
    const lastDateWorked: Record<string, Date> = {};

    // --- RULE: EBD (Saturdays) ---
    // Select 2 professors for the whole month
    const saturdays = events.filter(e => e.event_type === 'sabado');
    let ebdPair: Volunteer[] = [];

    if (saturdays.length > 0) {
      log('Selecionando dupla da EBD...');
      // Logic to pick pair (simplified for MVP: pick 2 random distinct professors)
      const professors = volunteers.filter(v => v.role === 'professor');
      if (professors.length < 2) throw new Error('Professores insuficientes para EBD');

      // Sort by least used (fairness) - although for EBD they are "fixed" for the month
      // In a real scenario, we check history. For MVP, random or first available.
      // Let's implement simple rotation rule: exclude last month's pair if possible.

      // Shuffle professors for randomness
      const shuffledProfs = [...professors].sort(() => Math.random() - 0.5);
      ebdPair = [shuffledProfs[0], shuffledProfs[1]];

      log(`Dupla EBD selecionada: ${ebdPair[0].name} e ${ebdPair[1].name}`);

      // Assign to Saturdays
      saturdays.forEach((event, index) => {
        // Person A works even Saturdays (idx 0, 2...), Person B works odd (idx 1, 3...)
        // actually let's just alternate
        const prof = ebdPair[index % 2];
        const aux = findAuxiliary(volunteers, event, unavailableSet, lastDateWorked, usageCount);

        addToSchedule(schedule, event, prof, 'professor', 'unificada', usageCount, lastDateWorked);
        if (aux) addToSchedule(schedule, event, aux, 'auxiliar', 'unificada', usageCount, lastDateWorked);
      });
    }

    // --- RULE: Tuesdays (3 Rooms) and Sundays (2 Rooms) ---
    const regularEvents = events.filter(e => e.event_type !== 'sabado');

    for (const event of regularEvents) {
      log(`Processando evento: ${event.event_date} (${event.event_type})`);

      if (event.event_type === 'terca') {
        // Needs: 1 Prof Bebes, 1 Prof Pequenos, 1 Prof Grandes, 1 Auxiliar
        processRoom(volunteers, event, 'bebes', schedule, unavailableSet, lastDateWorked, usageCount, log);
        processRoom(volunteers, event, 'pequenos', schedule, unavailableSet, lastDateWorked, usageCount, log);
        processRoom(volunteers, event, 'grandes', schedule, unavailableSet, lastDateWorked, usageCount, log);

        const aux = findAuxiliary(volunteers, event, unavailableSet, lastDateWorked, usageCount);
        if (aux) addToSchedule(schedule, event, aux, 'auxiliar', null, usageCount, lastDateWorked);
        else log(`⚠️ AVISO: Não foi possível encontrar auxiliar para ${event.event_date}`);

      } else if (event.event_type === 'domingo') {
        // Needs: 1 Prof Bebes, 1 Prof Pequenos, 1 Auxiliar
        processRoom(volunteers, event, 'bebes', schedule, unavailableSet, lastDateWorked, usageCount, log);
        processRoom(volunteers, event, 'pequenos', schedule, unavailableSet, lastDateWorked, usageCount, log);

        const aux = findAuxiliary(volunteers, event, unavailableSet, lastDateWorked, usageCount);
        if (aux) addToSchedule(schedule, event, aux, 'auxiliar', null, usageCount, lastDateWorked);
        else log(`⚠️ AVISO: Não foi possível encontrar auxiliar para ${event.event_date}`);
      }
    }

    // Save to DB
    if (schedule.length > 0) {
      const { error: insertError } = await supabase.from('schedules').insert(schedule);
      if (insertError) throw insertError;
      log(`Escala salva com sucesso! ${schedule.length} agendamentos criados.`);
    }

    return { success: true, message: 'Escala gerada com sucesso!', schedule, logs };

  } catch (error: any) {
    console.error(error);
    return { success: false, message: error.message, logs };
  }
}

// Helper: Ensure events exist
export async function ensureEventsExist(month: number, year: number) {
  // Simple implementation: Generate all Tue, Sat, Sun
  const start = new Date(year, month - 1, 1);
  const end = new Date(year, month, 0);
  const newEvents = [];

  for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
    const day = d.getDay();
    let type: EventType | null = null;
    if (day === 0) type = 'domingo';
    if (day === 2) type = 'terca';
    if (day === 6) type = 'sabado';

    if (type) {
      newEvents.push({
        event_date: d.toISOString().split('T')[0],
        event_type: type,
        month,
        year,
        is_published: false
      });
    }
  }

  if (newEvents.length > 0) {
    await supabase.from('events').upsert(newEvents, { onConflict: 'event_date' });
  }
}

// Helper: Process a specific room assignment
function processRoom(
  volunteers: Volunteer[],
  event: Event,
  room: Room,
  schedule: ScheduleEntry[],
  unavailableSet: Set<string>,
  lastDateWorked: Record<string, Date>,
  usageCount: Record<string, number>,
  log: (msg: string) => void
) {
  // Filter candidates:
  // 1. Must be 'professor'
  // 2. Must match room
  // 3. Must not be unavailable
  // 4. Must NOT have worked yesterday (consecutive day rule)
  // 5. Must NOT be already scheduled today (though this is implicitly handled by processing order if we don't duplicate)

  const eventDate = new Date(event.event_date);
  const yesterday = new Date(eventDate);
  yesterday.setDate(yesterday.getDate() - 1);

  const candidates = volunteers.filter(v => {
    if (v.role !== 'professor') return false;
    if (v.room !== room) return false;
    if (unavailableSet.has(`${v.id}_${event.id}`)) return false;

    // Check consecutive days
    const last = lastDateWorked[v.id];
    if (last && last.getTime() === yesterday.getTime()) return false;

    // Check if already scheduled today
    if (last && last.getTime() === eventDate.getTime()) return false;

    return true;
  });

  if (candidates.length === 0) {
    log(`⚠️ AVISO: Nenhum professor disponível para sala ${room} em ${event.event_date}`);
    return;
  }

  // Soft Constraint: Fairness
  // Sort by usage count (asc) => pick the one with least work
  candidates.sort((a, b) => {
    const countA = usageCount[a.id] || 0;
    const countB = usageCount[b.id] || 0;
    return countA - countB || Math.random() - 0.5; // Tie-break with randomness
  });

  const selected = candidates[0];
  addToSchedule(schedule, event, selected, 'professor', room, usageCount, lastDateWorked);
}

// Helper: Find Available Auxiliary
function findAuxiliary(
  volunteers: Volunteer[],
  event: Event,
  unavailableSet: Set<string>,
  lastDateWorked: Record<string, Date>,
  usageCount: Record<string, number>
): Volunteer | null {
  const eventDate = new Date(event.event_date);
  const yesterday = new Date(eventDate);
  yesterday.setDate(yesterday.getDate() - 1);

  // Candidates: Explicit Auxiliaries first, then Professors if needed (optional rule, let's stick to strict auxiliaries for now per "Constitution")
  // Actually "3 Professores + 1 Auxiliar". So we look for role 'auxiliar'.

  const candidates = volunteers.filter(v => {
    if (v.role !== 'auxiliar') return false; // Strict role check
    if (unavailableSet.has(`${v.id}_${event.id}`)) return false;

    const last = lastDateWorked[v.id];
    if (last && last.getTime() === yesterday.getTime()) return false;
    if (last && last.getTime() === eventDate.getTime()) return false;

    return true;
  });

  if (candidates.length === 0) return null;

  // Fairness sort
  candidates.sort((a, b) => (usageCount[a.id] || 0) - (usageCount[b.id] || 0) || Math.random() - 0.5);

  return candidates[0];
}

// Helper: Add to schedule array and update tracking refs
function addToSchedule(
  schedule: ScheduleEntry[],
  event: any,
  volunteer: Volunteer,
  role: 'professor' | 'auxiliar',
  room: string | null,
  usageCount: Record<string, number>,
  lastDateWorked: Record<string, Date>
) {
  schedule.push({
    event_id: event.id,
    volunteer_id: volunteer.id,
    assigned_role: role,
    assigned_room: room,
    month: event.month,
    year: event.year
  });

  usageCount[volunteer.id] = (usageCount[volunteer.id] || 0) + 1;
  lastDateWorked[volunteer.id] = new Date(event.event_date);
}
